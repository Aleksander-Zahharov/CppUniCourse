// Этот файл содержит настройки для тасков Visual Studio Code, 
// которые позволяют запускать компилятор и сборщик проекта через кнопку RUN,
// или через команду в терминале/Ctrl+Shift+P -> Run Task -> "название таска".
// По сути, с запуском таска, в терминал всегда вводятся command + args 

// Кнопка RUN 
// запустит тот таск, который помечен как "isDefault":true в "group"... Не совсем...
// VSCode автоматически выбирает подходящий таск для кнопки RUN, основываясь на текущем открытом файле и его типе.
// Если запускать файл через терминал/Ctrl+Shift+P -> Run Task, то файл скомпилируется, но не запустится (если это в таск не указано).
// А если запустить через кнопку RUN, то файл еще и запустится после компиляции.
// А если указать в таске, что файл нужно запустить после компиляции И запустить таск через кнопку RUN, то файл НЕ запустится 2 раза (только 1)
{ 
    "tasks": [ 	// Список тасков для компиляции
				// через Ctrl+Shift+P -> Run Task -> "Обычный таск: Скомпилировать HelloWorld0 (без Makefile)"
				// (в верхнем input field)

		{	// Этот таск компилирует файл(ы) из списка в args и создает .exe файл(только 1 exe файл) в той же папке, что и исходный файл,
			// но не запускает его (если не использовать кнопку RUN, а запускать через консоль/Ctrl+Shift+P -> Run Task -> C/C++: g++.exe build active file. LAB 0)
			// Этот таск просто пишет в консоль "C:/msys64/ucrt64/bin/g++.exe -fdiagnostics-color=always -g HelloWorld0.cpp -o HelloWorld0.exe"
            "type": "cppbuild",
            "label": "Обычный таск: Скомпилировать HelloWorld0 (без Makefile)",
            "command": "C:/msys64/ucrt64/bin/g++.exe", // "Проблема заключается в том, что компилятор не может найти определения для стандартных потоков ввода-вывода C++ (std::cout, std::endl и т.д.).
                                                        // Это происходит потому, что вы используете компилятор gcc, который по умолчанию компилирует C-код, а не C++."
            "args": [	
                "-fdiagnostics-color=always",
                "-g",
                "${file}",	// Можно заменить на "HelloWorld0.cpp", тогда таск можно будет запускать откуда угодно, а не только из открытого файла, как в случае с "${file}"
							// При создании нового .cpp файла, нужно будет добавить СЮДА в список название этого файла. но тогда при компиляции будет компилироваться все файлы из списка,
							// даже если в них не было изменений. Поэтому лучше создать новый таск для нового файла. Либо просто добавить новый файл в список в Makefile...
                "-o",
                "${fileDirname}\\${fileBasenameNoExtension}.exe"	// ...И тут тоже поменять надо будет на "HelloWorld0.exe"...
																	// ...однако я щас так попробовал поменять и ничего не получилось))) но в теории должно работать, нав он папку не парвильно видит, хз
            ],
            "options": {
                "cwd": "C:/msys64/ucrt64/bin"
            },
            "problemMatcher": [		// "В данном случае, использование $gcc в problemMatcher подходит как для gcc, так и для g++, 
                "$gcc"				// так как оба компилятора выводят ошибки и предупреждения в одном и том же формате."
            ],						// Но использование gcc - это стандартная практика как для gcc (C) компайлеров, так и для g++ (C/C++).
            "group": {
                "kind": "build",
                "isDefault": true	// Этот таск будет выполняться по нажатию кнопки RUN
            },
            "detail": "Task generated by Debugger (и отредачен мной)"
        },

		{	// Добавляет в верхнее input field еще один таск
			// Он скомпилирует и запустит проект, используя Makefile
			// Ctrl+Shift+P -> Run Task -> "Make: build and run HelloWorld0 !!1"
			// Этот таск просто пишет в консоль "make run", а определение этой функции находится в Makefile
			// В Makefile можно создавать любые команды "make *что_угодно*"
            "label": "Make: build and run HelloWorld0 !!1",
            "type": "shell",
            "command": "make",
            "args": [
                "run"		// Функция make run в вашем Makefile выполняет следующие действия:
							// 1. Сначала выполняет цель build, которая компилирует программу.
							// 2. Затем запускает скомпилированную программу.
							// В Makefile:
							// run: build
    						//	./$(PROGRAM)
            ],
            "group": {
                "kind": "build",
                "isDefault": false
            },
            "problemMatcher": []
        },

        {	// Добавляет в верхнее input field таск с возможность выполнить
			// команду в терминале "make clean" для удаления всех файлов,
			// созданных в процессе компиляции. Таких как .exe, .o и т.д.
			// Ctrl+Shift+P -> Run Task -> "Make: clean !!1"
            "label": "Make: clean !!1",
            "type": "shell",
            "command": "make",
            "args": [
                "clean"
            ],
            "group": {
                "kind": "build",
                "isDefault": false
            },
            "problemMatcher": []
        },

		{	// Таск для компиляции и запуска PointersTests0.cpp без Makefile
			// Можно и в makefile сделать так чтобы отдельно компилировались разные exe файлы
			// и написать для их компиляции и запуска 2 разных таска,
			// но легче просто такой обычный таск добавить 
			"type": "shell",
			"label": "Обычный таск: Скомпилировать и запустить PointersTests0 (без Makefile)",
			"command": "cmd",
			"args": [
				"/c",
        		"C:/msys64/ucrt64/bin/g++.exe -fdiagnostics-color=always -g PointersTests0.cpp -o ${fileDirname}/PointersTests0.exe && ${fileDirname}\\PointersTests0.exe"	// Компилируем и запускаем(!) PointersTests0.cpp
				// Если запустить этот таск через кнопку RUN, то файл НЕ запустится 2 раза (только 1)
			],
			"options": {
				"cwd": "${workspaceFolder}" // Устанавливаем текущую рабочую директорию
			},
			"problemMatcher": [
				"$gcc"
			],
			"group": {
				"kind": "build",
				"isDefault": false // Этот таск не будет запускаться по кнопке RUN
			},
			"detail": "Таск для компиляции и запуска PointersTests0.cpp без Makefile"
		}
    ],
    "version": "2.0.0"
}